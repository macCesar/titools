# Alloy MVC + PurgeTSS Structure Reference

## Standard Project Structure

```
app/
├── controllers/           # View orchestrators
│   ├── index.js          # Bootstrap only (no business logic)
│   └── feature/
│       └── list.js       # Controller for list view
├── models/               # OPTIONAL: For persistence with migrations
│   └── user.js           # Model definition (ONLY if using SQLite)
├── views/                # XML views styled with PurgeTSS
│   ├── index.xml
│   └── feature/
│       ├── list.xml      # View definition (Utility classes here)
├── lib/                  # Reusable logic (no UI)
│   ├── api/
│   │   └── client.js     # API calls
│   ├── services/
│   │   ├── auth.js       # Business logic services
│   │   ├── navigation.js # Navigation orchestration
│   │   ├── nativeService.js # Native module wrapper (e.g. Audio, FB, Maps)
│   │   └── purgetss.animation.js # PurgeTSS Animation module
│   └── helpers/
│       ├── utils.js      # Pure utility functions
│       └── i18n.js       # Complex string transformations
├── widgets/              # Truly reusable components (used in 3+ places)
│   └── customButton/
├── styles/               # Global styles
│   ├── app.tss            # GENERATED by PurgeTSS (Do not edit)
│   ├── _app.tss           # YOUR custom styles (persists across runs)
│   └── fonts.tss          # GENERATED by PurgeTSS build-fonts
├── config.json           # Alloy configuration
└── alloy.js              # Collections & Global services

./purgetss/
├── config.cjs             # PurgeTSS theme configuration
└── styles/
    └── tailwind.tss       # All utility classes
```

## Data Layer: Two Approaches

### Approach A: Alloy Models (app/models/) - For Persistence

**Use when:**
- You need SQLite persistence
- You need schema migrations between app versions
- You need offline-first functionality

```javascript
// app/models/User.js
exports.definition = {
  config: {
    columns: {
      id: 'INTEGER PRIMARY KEY',
      name: 'TEXT',
      email: 'TEXT'
    },
    adapter: {
      type: 'sql',
      collection_name: 'users'
    }
  }
}

// Usage
const users = Alloy.createCollection('User')
users.fetch()
```

---

### Approach B: Backbone Collections Direct (alloy.js) - For API Data

**Use when:**
- Data comes from APIs
- No local persistence needed
- You want simplicity and flexibility

```javascript
// alloy.js - Define collections globally
Alloy.Collections.frames = new Backbone.Collection()
Alloy.Collections.mockups = new Backbone.Collection()
```

**In views - bind with dataCollection:**
```xml
<ListSection id="section" dataCollection="frames">
  <ListItem title:text="{title}" />
</ListSection>
```

**In controllers - manipulate directly:**
```javascript
// Reset collection
Alloy.Collections.frames.reset()

// Add items
Alloy.Collections.frames.add(newItem)

// Fetch from API
api.getFrames()
  .then(frames => Alloy.Collections.frames.reset(frames))
```

## Controller Rules

**DO:**
- Use **PurgeTSS classes** in XML for 100% of the styling.
- Orchestrate view and model/collection interactions.
- Handle UI events and delegate to services.
- Format data for display (simple cases).
- Manage view lifecycle (including cleanup).

**DON'T:**
- Create per-controller `.tss` files (Use PurgeTSS utility classes).
- Make direct API calls (use lib/api/ or lib/services/).
- Contain heavy business logic.
- Call native modules directly (use a service wrapper).

## Navigation & Cleanup Pattern

### Automatic Cleanup with ControllerAutoCleanup

For automatic controller cleanup without code changes, use the ControllerAutoCleanup utility.

**Installation:**

1. Copy `ControllerAutoCleanup.js` to `app/lib/`
2. Add as first line in `alloy.js`:

```javascript
// alloy.js
require('ControllerAutoCleanup')

// Rest of your alloy.js initialization...
Alloy.Collections.frames = new Backbone.Collection()
```

**How it works:**

- Monkey-patches `Alloy.createController` to add automatic cleanup
- Listens for `close` events and recursively cleans up controllers
- No code changes needed - existing `Alloy.createController().getView().open()` calls get cleanup automatically

**Benefits:**

| Without ControllerAutoCleanup              | With ControllerAutoCleanup |
| ------------------------------------------ | -------------------------- |
| Must remember manual cleanup               | Cleanup automatic          |
| Easy to forget, causes memory leaks        | Memory leaks prevented     |
| Repetitive code in each navigation service | One-line install           |

See [ControllerAutoCleanup.js](../assets/ControllerAutoCleanup.js) for the complete source code.

## i18n and Accessibility Rules

- All static text must use `L('key')`.
- All interactive elements must have `accessibilityLabel`.
- Use `lib/helpers/i18n.js` for strings that require logic (e.g., "You have 5 messages").
- Use **PurgeTSS modifiers** for platform-specific design instead of conditional code.

## Widget Structure

Widgets are self-contained, reusable components used in 3+ places across the app.

```
app/widgets/
└── loadingOverlay/
    ├── controllers/
    │   └── widget.js      # Main widget controller
    ├── views/
    │   └── widget.xml     # Main widget view
    ├── styles/
    │   └── widget.tss     # Widget-specific styles (optional with PurgeTSS)
    └── widget.json        # Widget manifest
```

### widget.json Configuration
```json
{
  "id": "com.app.loadingOverlay",
  "name": "Loading Overlay",
  "description": "Full-screen loading indicator with optional message",
  "author": "Your Name",
  "version": "1.0.0",
  "copyright": "Copyright (c) 2024",
  "license": "MIT",
  "min-alloy-version": "1.0.0",
  "min-titanium-version": "9.0.0",
  "tags": "ui, loading",
  "platforms": "android,ios"
}
```

### Widget View (widget.xml)
```xml
<Alloy>
  <View id="container" class="wh-screen hidden bg-black/50">
    <View class="wh-32 vertical rounded-2xl bg-white">
      <ActivityIndicator id="spinner" class="mt-6" />
      <Label id="messageLabel" class="mx-4 mt-4 text-sm text-gray-600" />
    </View>
  </View>
</Alloy>
```

### Widget Controller (widget.js)
```javascript
// Widget controller receives args via $.args
const args = $.args || {}

// Initialize with defaults
let message = args.message || L('loading')

// Public API
$.show = (msg) => {
  if (msg) message = msg
  $.messageLabel.text = message
  $.spinner.show()
  $.container.visible = true
}

$.hide = () => {
  $.spinner.hide()
  $.container.visible = false
}

$.setMessage = (msg) => {
  $.messageLabel.text = msg
}

// Cleanup
$.cleanup = () => {
  $.spinner.hide()
  $.destroy()
}
```

### Using Widgets
```xml
<!-- In any view -->
<Alloy>
  <Window>
    <!-- Your content -->

    <!-- Add widget -->
    <Widget id="loader" src="loadingOverlay" message="L('please_wait')" />
  </Window>
</Alloy>
```

```javascript
// In controller
const loadData = () => {
  $.loader.show(L('loading_data'))

  api.fetchData()
    .then(renderData)
    .finally(() => $.loader.hide())
}
```

:::tip PurgeTSS with Widgets
If your widget uses PurgeTSS utility classes (as shown in the example above), you must enable widget processing in `./purgetss/config.cjs`:

```javascript
// ./purgetss/config.cjs
module.exports = {
  purge: {
    options: {
      widgets: true  // Enable PurgeTSS class processing for widgets
    }
  }
}
```

Without this setting, PurgeTSS will NOT process classes in widget files.
:::

## config.json Reference

The `app/config.json` file configures Alloy compilation and runtime behavior.

```json
{
  "global": {
    "theme": "default"
  },
  "env:development": {
    "apiUrl": "https://dev-api.example.com",
    "debug": true,
    "logLevel": "debug"
  },
  "env:test": {
    "apiUrl": "https://staging-api.example.com",
    "debug": true,
    "logLevel": "info"
  },
  "env:production": {
    "apiUrl": "https://api.example.com",
    "debug": false,
    "logLevel": "error"
  },
  "os:android": {
    "androidSpecificSetting": true
  },
  "os:ios": {
    "iosSpecificSetting": true
  },
  "dependencies": {
    "com.app.loadingOverlay": "1.0"
  },
  "autoStyle": false,
  "backbone": "1.4.0",
  "sourcemap": true
}
```

### Accessing Config Values
```javascript
// In any controller or lib file
const apiUrl = Alloy.CFG.apiUrl
const isDebug = Alloy.CFG.debug
const logLevel = Alloy.CFG.logLevel

// Environment check
if (Alloy.CFG.debug) {
  console.log('Debug mode enabled')
}
```

### Key Configuration Options

| Property       | Description                                       |
| -------------- | ------------------------------------------------- |
| `theme`        | Theme folder to use from `app/themes/`            |
| `autoStyle`    | Auto-apply TSS styles (set `false` with PurgeTSS) |
| `backbone`     | Backbone.js version to use                        |
| `sourcemap`    | Generate source maps for debugging                |
| `dependencies` | Widget dependencies and versions                  |
| `adaptersPath` | Custom path for sync adapters                     |
