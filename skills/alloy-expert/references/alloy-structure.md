# Alloy MVC + PurgeTSS Structure Reference

## Standard Project Structure

```
app/
├── controllers/           # View orchestrators
│   ├── index.js          # Bootstrap only (no business logic)
│   └── feature/
│       └── list.js       # Controller for list view
├── models/               # OPTIONAL: For persistence with migrations
│   └── user.js           # Model definition (ONLY if using SQLite)
├── views/                # XML views styled with PurgeTSS
│   ├── index.xml
│   └── feature/
│       ├── list.xml      # View definition (Utility classes here)
├── lib/                  # Reusable logic (no UI)
│   ├── api/
│   │   └── client.js     # API calls
│   ├── services/
│   │   ├── auth.js       # Business logic services
│   │   ├── navigation.js # Navigation orchestration
│   │   ├── nativeService.js # Native module wrapper (e.g. Audio, FB, Maps)
│   │   └── purgetss.animation.js # PurgeTSS Animation module
│   └── helpers/
│       ├── utils.js      # Pure utility functions
│       └── i18n.js       # Complex string transformations
├── widgets/              # Truly reusable components (used in 3+ places)
│   └── customButton/
├── styles/               # Global styles
│   ├── app.tss            # GENERATED by PurgeTSS (Do not edit)
│   ├── _app.tss           # YOUR custom styles (persists across runs)
│   └── fonts.tss          # GENERATED by PurgeTSS build-fonts
├── config.json           # Alloy configuration
└── alloy.js              # Collections & Global services

./purgetss/
├── config.cjs             # PurgeTSS theme configuration
└── styles/
    └── tailwind.tss       # All utility classes
```

## Data Layer: Two Approaches

### Approach A: Alloy Models (app/models/) - For Persistence

**Use when:**
- You need SQLite persistence
- You need schema migrations between app versions
- You need offline-first functionality

```javascript
// app/models/User.js
exports.definition = {
  config: {
    columns: {
      id: 'INTEGER PRIMARY KEY',
      name: 'TEXT',
      email: 'TEXT'
    },
    adapter: {
      type: 'sql',
      collection_name: 'users'
    }
  }
}

// Usage
const users = Alloy.createCollection('User')
users.fetch()
```

---

### Approach B: Backbone Collections Direct (alloy.js) - For API Data

**Use when:**
- Data comes from APIs
- No local persistence needed
- You want simplicity and flexibility

```javascript
// alloy.js - Define collections globally
Alloy.Collections.frames = new Backbone.Collection()
Alloy.Collections.mockups = new Backbone.Collection()
```

**In views - bind with dataCollection:**
```xml
<ListSection id="section" dataCollection="frames">
  <ListItem title:text="{title}" />
</ListSection>
```

**In controllers - manipulate directly:**
```javascript
// Reset collection
Alloy.Collections.frames.reset()

// Add items
Alloy.Collections.frames.add(newItem)

// Fetch from API
api.getFrames()
  .then(frames => Alloy.Collections.frames.reset(frames))
```

## Controller Rules

**DO:**
- Use **PurgeTSS classes** in XML for 100% of the styling.
- Orchestrate view and model/collection interactions.
- Handle UI events and delegate to services.
- Format data for display (simple cases).
- Manage view lifecycle (including cleanup).

**DON'T:**
- Create per-controller `.tss` files (Use PurgeTSS utility classes).
- Make direct API calls (use lib/api/ or lib/services/).
- Contain heavy business logic.
- Call native modules directly (use a service wrapper).

## Navigation & Cleanup Pattern

```javascript
// lib/services/navigation.js
export function open(route, params) {
  const controller = Alloy.createController(route, params)
  const view = controller.getView()
  
  view.addEventListener('close', () => {
    if (controller.cleanup) {
      controller.cleanup()
    }
  })
  
  view.open()
}
```

## i18n and Accessibility Rules

- All static text must use `L('key')`.
- All interactive elements must have `accessibilityLabel`.
- Use `lib/helpers/i18n.js` for strings that require logic (e.g., "You have 5 messages").
- Use **PurgeTSS modifiers** for platform-specific design instead of conditional code.