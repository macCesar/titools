/**
 * Utility functions
 * Block management, color output, and helper functions
 */

import { readFileSync, writeFileSync, existsSync, readdirSync } from 'fs';
import { resolve, join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { BLOCK_START, BLOCK_END, TITANIUM_KNOWLEDGE_VERSION } from './config.js';

// Get package root directory (works for both npm install and npm link)
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const packageRoot = resolve(__dirname, '..');
const packageSkillsDir = join(packageRoot, 'skills');

/**
 * Check if Titanium knowledge block exists in a file
 * @param {string} filePath - Path to the file
 * @returns {boolean} True if block exists
 */
export function blockExists(filePath) {
  if (!existsSync(filePath)) {
    return false;
  }

  const content = readFileSync(filePath, 'utf8');
  // Match both old versioned blocks and new static blocks
  return /<!-- TITANIUM-KNOWLEDGE-(v[\d.]+|START) -->/.test(content);
}

/**
 * Remove old Titanium knowledge block from a file
 * @param {string} filePath - Path to the file
 * @returns {boolean} True if block was removed
 */
export function removeOldBlock(filePath) {
  if (!existsSync(filePath)) {
    return false;
  }

  const content = readFileSync(filePath, 'utf8');
  // Regex to match any Titanium knowledge block (old or new)
  const regex = /[\s\S]*?<!-- TITANIUM-KNOWLEDGE-(v[\d.]+|START) -->[\s\S]*?<!-- (END-TITANIUM-KNOWLEDGE|TITANIUM-KNOWLEDGE-END) -->[\s\S]*?\n*/g;

  const newContent = content.replace(regex, '\n\n');

  writeFileSync(filePath, newContent, 'utf8');
  return true;
}

/**
 * Build the compressed documentation index dynamically by scanning skills
 * @returns {string} The compressed index section
 */
export function buildKnowledgeIndex() {
  let skills = [];

  try {
    skills = readdirSync(packageSkillsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name);
  } catch (error) {
    throw new Error(`Cannot read skills directory from package: ${packageSkillsDir}`);
  }

  const indexEntries = [];

  for (const skill of skills.sort()) {
    const refsDir = join(packageSkillsDir, skill, 'references');

    if (existsSync(refsDir)) {
      const files = readdirSync(refsDir)
        .filter(f => f.endsWith('.md'))
        .sort();

      if (files.length > 0) {
        indexEntries.push(`${skill}/references:{${files.join(',')}}`);
      }
    }
  }

  // Build the compressed index format
  // Note: Using \u0060 to avoid backtick parsing issues in template literals
  return '### Compressed Documentation Index\n\n' +
    '\u0060\u0060\u0060\n' +
    '[Titanium SDK Docs Index]|root: ~/.agents/skills\n' +
    '|' + indexEntries.join('\n|') + '\n' +
    '\u0060\u0060\u0060';
}

/**
 * Create the Titanium knowledge block content dynamically
 * @returns {string} The knowledge block content
 */
export function createKnowledgeBlock() {
  // Build the compressed index dynamically
  const compressedIndex = buildKnowledgeIndex();

  // Build the knowledge block using template literals
  const blockHeader = `${BLOCK_START}\n<!-- Version: ${TITANIUM_KNOWLEDGE_VERSION} -->`;
  const commentContent = `## Titanium SDK Knowledge Index

Generated by \`titools\` based on Vercel's research on AGENTS.md effectiveness.

**IMPORTANT**: Prefer retrieval-led reasoning over pre-training-led reasoning when working with Titanium SDK.
Always consult the documentation files below rather than relying on training data, which may be outdated.

This knowledge index is based on the latest Titanium SDK documentation.`;

  return `\n\n${blockHeader}\n${commentContent}\n\n${compressedIndex}\n${BLOCK_END}\n`;
}

/**
 * Add or update Titanium knowledge block in a file
 * @param {string} filePath - Path to the file
 * @returns {boolean} True if file was updated
 */
export function addOrUpdateBlock(filePath) {
  let content = '';

  if (existsSync(filePath)) {
    content = readFileSync(filePath, 'utf8');
  }

  const block = createKnowledgeBlock();

  // Regex to find ALL existing blocks (old versioned or new static)
  // Global flag /g is CRITICAL here to remove every single occurrence
  const globalBlockRegex = /<!-- TITANIUM-KNOWLEDGE-(v[\d.]+|START) -->[\s\S]*?<!-- (END-TITANIUM-KNOWLEDGE|TITANIUM-KNOWLEDGE-END) -->/g;
  
  // Clean up all existing blocks to prevent accumulation
  content = content.replace(globalBlockRegex, '').trim();

  // Add new block at the end (preserve existing content)
  content = content.trimEnd() + '\n\n' + block + '\n';

  writeFileSync(filePath, content, 'utf8');
  return true;
}
/**
 * Detect Titanium SDK version from tiapp.xml
 * @param {string} projectDir - Path to project directory
 * @returns {string} SDK version or 'unknown'
 */
export function detectTitaniumVersion(projectDir) {
  const tiappPath = join(projectDir, 'tiapp.xml');

  if (!existsSync(tiappPath)) {
    return 'unknown';
  }

  const content = readFileSync(tiappPath, 'utf8');
  const match = content.match(/<sdk-version>([^<]+)<\/sdk-version>/);

  return match ? match[1].trim() : 'unknown';
}

/**
 * Check if directory is a Titanium project
 * @param {string} dir - Path to check
 * @returns {boolean}
 */
export function isTitaniumProject(dir) {
  return existsSync(join(dir, 'tiapp.xml'));
}

/**
 * Get AI configuration files that exist in a directory
 * @param {string} dir - Path to check
 * @returns {Object} Object with boolean flags for each file type
 */
export function getAIFiles(dir) {
  return {
    claude: existsSync(join(dir, 'CLAUDE.md')),
    gemini: existsSync(join(dir, 'GEMINI.md')),
    agents: existsSync(join(dir, 'AGENTS.md')),
  };
}

/**
 * Determine which AI files to update based on priority
 * @param {Object} aiFiles - Object with boolean flags for each file type
 * @returns {Array} Array of file names to update (priority order)
 */
export function determineFilesToUpdate(aiFiles) {
  const files = [];

  // Priority: CLAUDE.md > GEMINI.md > AGENTS.md
  if (aiFiles.claude) {
    files.push('CLAUDE.md');
    if (aiFiles.gemini) files.push('GEMINI.md');
    if (aiFiles.agents) files.push('AGENTS.md');
  } else if (aiFiles.gemini) {
    files.push('GEMINI.md');
    if (aiFiles.agents) files.push('AGENTS.md');
  } else if (aiFiles.agents) {
    files.push('AGENTS.md');
  }

  return files;
}

/**
 * Format a list of items for display
 * @param {Array} items - Array of strings
 * @returns {string} Comma-separated list
 */
export function formatList(items) {
  return items.join(', ');
}

/**
 * Parse SDK version string to compare
 * @param {string} version - Version string (e.g., "13.1.0.GA")
 * @returns {Array} Array of version parts
 */
export function parseVersion(version) {
  return version
    .replace('.GA', '')
    .replace('.RC', '-')
    .split(/[.-]/)
    .map((v) => parseInt(v, 10) || 0);
}

/**
 * Compare two version strings
 * @param {string} v1 - First version
 * @param {string} v2 - Second version
 * @returns {number} -1 if v1 < v2, 0 if equal, 1 if v1 > v2
 */
export function compareVersions(v1, v2) {
  const parts1 = parseVersion(v1);
  const parts2 = parseVersion(v2);

  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    const p1 = parts1[i] || 0;
    const p2 = parts2[i] || 0;

    if (p1 < p2) return -1;
    if (p1 > p2) return 1;
  }

  return 0;
}

export default {
  blockExists,
  removeOldBlock,
  createKnowledgeBlock,
  addOrUpdateBlock,
  detectTitaniumVersion,
  isTitaniumProject,
  getAIFiles,
  determineFilesToUpdate,
  formatList,
  parseVersion,
  compareVersions,
};
